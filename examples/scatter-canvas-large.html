---
layout: example
title: Scatter Plot Brushing - Canvas, Large Dataset
---

<div class="row justify-content-center text-center">
  <div class="col-12 max-width-800">
    <p>
      Plotting 20,000 data points in 2 plots. Plots may take several seconds to
      load. Brush on one chart to see the points filtered on the other. Compare
      against performance using SVG backend in the
      <a href="scatter-svg-large.html">SVG scatter plot example</a>.

      The Canvas backed Scatter plots behave incorrectly when resized. So, this example uses fixed sizes.
      TODO: investigate and fix.
    </p>
  </div>
</div>
<div class="row justify-content-center text-center">
  <div class="col max-width-360">
    <div id="test1" style="width: 350px; height: 300px"></div>
  </div>
  <div class="col max-width-360">
    <div id="test2" style="width: 350px; height: 300px"></div>
  </div>
</div>

<script type="text/javascript">
  const chartGroup = new dc.ChartGroup();
  d3.csv('sampleData20000.csv').then(rowData => {
    rowData.forEach(d => {
      d.feature1 = +d.feature1;
      d.feature2 = +d.feature2;
      d.feature3 = +d.feature3;
      d.class = +d.class;
    });

    // Calculate x and y binning with each bin being PIXEL_BIN_SIZE wide.
    // Binning coordinates into bins such that 1-2 bins per pixel makes
    // crossfilter operations more efficient, especially with large
    // datasets
    const nXBins = 300;
    const binWidth = 20 / nXBins;

    const ndx = crossfilter(rowData),
      dim1 = ndx.dimension(d => [
        Math.floor(d.feature1 / binWidth) * binWidth,
        Math.floor(d.feature2 / binWidth) * binWidth,
        d.class,
      ]),
      dim2 = ndx.dimension(d => [
        Math.floor(d.feature2 / binWidth) * binWidth,
        Math.floor(d.feature3 / binWidth) * binWidth,
        d.class,
      ]),
      group1 = dim1.group(),
      group2 = dim2.group();

    const repositionLegends = chart => {
      const legend = chart.legend();
      const left = chart.width() - chart.margins().right - legend.legendWidth();
      const top = 10;
      legend.x(left).y(top);
    };

    const plotColorMap = { 0: '#ff7f0e', 1: '#2ca02c' };
    const chart1 = new dc.ScatterPlot('#test1', chartGroup)
      .dataProvider(
        new dc.CFSimpleAdapter({
          valueAccessor: d => d.key[1],
          dimension: dim1,
          group: group1,
        })
      )
      .configure({
        useCanvas: true,
        keyAccessor: d => d.key[0],
        clipPadding: 10,
        highlightedSize: 4,
        symbolSize: 3,
        excludedSize: 2,
        excludedOpacity: 0.5,
        excludedColor: '#ddd',
        colorAccessor: d => d.key[2],
      })
      .x(d3.scaleLinear().domain([-8, 8]))
      .yAxisLabel('Feature 2')
      .xAxisLabel('Feature 1')
      .colorScale(colorKey => plotColorMap[colorKey])
      .legend(
        new dc.Legend().itemHeight(13).gap(5).legendWidth(60).itemWidth(70)
      )
      .on('preRender', repositionLegends)
      .on('preRedraw', repositionLegends);

    chart1.legendables = function () {
      return [
        { name: 'Class 0', chart: chart1, color: plotColorMap[0] },
        { name: 'Class 1', chart: chart1, color: plotColorMap[1] },
      ];
    };

    const chart2 = new dc.ScatterPlot('#test2', chartGroup)
      .dataProvider(
        new dc.CFSimpleAdapter({
          dimension: dim2,
          group: group2,
          valueAccessor: d => d.key[1],
        })
      )
      .configure({
        useCanvas: true,
        clipPadding: 10,
        highlightedSize: 4,
        symbolSize: 3,
        excludedSize: 2,
        excludedOpacity: 0.5,
        excludedColor: '#ddd',
        colorAccessor: d => d.key[2],
      })
      .x(d3.scaleLinear().domain([-8, 8]))
      .yAxisLabel('Feature 2')
      .xAxisLabel('Feature 3')
      .colorScale(colorKey => plotColorMap[colorKey])
      .legend(
        new dc.Legend().itemHeight(13).gap(5).legendWidth(60).itemWidth(70)
      )
      .on('preRender', repositionLegends)
      .on('preRedraw', repositionLegends);

    chart2.legendables = function () {
      return [
        { name: 'Class 0', chart: chart2, color: plotColorMap[0] },
        { name: 'Class 1', chart: chart2, color: plotColorMap[1] },
      ];
    };

    chartGroup.renderAll();
  });
</script>
