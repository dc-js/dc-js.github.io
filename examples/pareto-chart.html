---
layout: example
title: Pareto Chart
---

<!--TODO: Rewrite using inheriting data adapter-->

<div class="row justify-content-center max-width-1000" style="margin: auto">
  <div class="col-12">
    <p>
      You can use
      <a href="https://github.com/dc-js/dc.js/wiki/FAQ#fake-groups"
        >fake groups</a
      >
      and a composite chart to implement a dynamic
      <a href="https://en.wikipedia.org/wiki/Pareto_chart">Pareto chart</a> in
      dc.js.
    </p>
  </div>
  <div class="col-12 col-md-3 order-md-2">
    <div
      id="pie-chart"
      class="ratio ratio-1x1"
      style="min-width: 100px; max-width: 150px; margin: 20px auto"
    ></div>
  </div>
  <div class="col-12 col-md-9 order-md-1">
    <div id="test_composed" class="ratio ratio-4x3"></div>
  </div>
</div>

<script type="text/javascript">
  const chartGroup = new dc.ChartGroup();
  const chart = new dc.CompositeChart('#test_composed', chartGroup),
    speedPie = new dc.PieChart('#pie-chart', chartGroup);

  const sampleData = [
    { reason: 'A', time: 1 },
    { reason: 'B', time: 6 },
    { reason: 'C', time: 6 },
    { reason: 'D', time: 5 },
    { reason: 'A', time: 5 },
    { reason: 'B', time: 5 },
    { reason: 'C', time: 8 },
    { reason: 'A', time: 8 },
    { reason: 'B', time: 2 },
    { reason: 'C', time: 2 },
    { reason: 'D', time: 10 },
    { reason: 'C', time: 7 },
    { reason: 'A', time: 3 },
    { reason: 'B', time: 4 },
    { reason: 'C', time: 2 },
  ];

  const ndx_ = crossfilter(sampleData),
    dim_ = ndx_.dimension(d => d.reason),
    allTime_ = dim_.groupAll().reduceSum(d => d.time),
    grp1_ = dim_.group().reduceSum(d => d.time);

  const speedDim_ = ndx_.dimension(d => Math.floor(d.time / 3));

  speedPie
    .dataProvider(
      new dc.CFSimpleAdapter({
        dimension: speedDim_,
        group: speedDim_.group(),
      })
    )
    .configure({
      minWidth: 50,
      minHeight: 50,
    });

  function paretoGroup(group, groupall) {
    return {
      all: function () {
        const total = groupall.value();
        let cumulate = 0;
        return group
          .all()
          .slice(0)
          .sort((a, b) => d3.descending(a.value, b.value))
          .map(({ key, value }) => ({
            key,
            value: {
              value,
              contribution: value / total,
              cumulative: (cumulate += value / total),
            },
          }));
      },
    };
  }

  const pg = paretoGroup(grp1_, allTime_);

  chart
    .dataProvider(
      new dc.CFSimpleAdapter({
        group: pg,
        ordering: kv => -kv.value.value,
      })
    )
    .configure({
      elasticX: true,
      clipPadding: 2,
      xUnits: dc.UnitsOrdinal,
      renderHorizontalGridLines: true,
    })
    .x(d3.scaleBand())
    ._rangeBandPadding(1)
    .yAxisLabel('The Y Axis')
    .legend(new dc.Legend().x(80).y(20).itemHeight(13).gap(5))
    .compose([
      new dc.BarChart(chart, chartGroup)
        .dataProvider(
          new dc.CFMultiAdapter({
            dimension: dim_,
            layers: [
              {
                group: pg,
                name: 'Contribution',
                valueAccessor: kv => kv.value.value,
              },
            ],
          })
        )
        .configure({
          centerBar: true,
          clipPadding: 10,
          brushOn: false,
        })
        .barPadding(1)
        .gap(1),
      new dc.LineChart(chart, chartGroup)
        .dataProvider(
          new dc.CFMultiAdapter({
            dimension: dim_,
            layers: [
              {
                group: pg,
                name: 'Cumulative %',
                valueAccessor: kv => Math.floor(kv.value.cumulative * 100),
              },
            ],
          })
        )
        .configure({
          useRightYAxis: true,
        })
        .colorScale(() => 'red')
        .dashStyle([2, 2]),
    ]);

  chart.rightYAxis().tickFormat(d => `${d}%`);

  chartGroup.renderAll();
</script>
