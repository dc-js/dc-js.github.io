---
layout: example
title: Filtering a Stacked Chart
additional_head: |
  <style>
    .dc-chart g.chart-body {
      clip-path: none;
    }
    .dc-chart rect.stack-deselected {
      opacity: 0.2;
    }
    #pie {
      min-width: 200px;
      max-width: 250px;
      margin: 20px auto;
    }
  </style>
---

<div class="row justify-content-center max-width-1000" style="margin: auto">
  <div class="col-12 col-md-3 order-md-2">
    <div id="pie" class="chart-with-reset ratio ratio-1x1">
      <div class="reset" style="visibility: hidden">
        range: <span class="filter"></span>
        <a href="javascript:pie.filterAll();chartGroup.redrawAll();">reset</a>
      </div>
    </div>
  </div>
  <div class="col-12 col-md-9 order-md-1">
    <div id="test" class="chart-with-reset ratio ratio-4x3">
      <div class="reset" style="visibility: hidden">
        selected: <span class="filter"></span>
        <a href="javascript:chart.filterAll();chartGroup.redrawAll();">reset</a>
      </div>
    </div>
  </div>
</div>

<script type="text/javascript">
  const chartGroup = new dc.ChartGroup();
  const chart = new dc.BarChart('#test', chartGroup),
    pie = new dc.PieChart('#pie', chartGroup);
  d3.csv('morley.csv').then(experiments => {
    experiments.forEach(x => {
      x.Speed = +x.Speed;
    });

    // the way to combine multiple keys into one is domain-specific (and controversial)
    // array keys are risky but also valid sometimes, that would be
    // function multikey(x,y) {
    //     return [x,y];
    // }
    // function splitkey(k) {
    //     return k;
    // }
    function multikey(x, y) {
      return `${x}x${y}`;
    }
    function splitkey(k) {
      return k.split('x');
    }
    function stackSecond(group) {
      return {
        all: function () {
          const all = group.all(),
            m = {};
          // build matrix from multikey/value pairs
          all.forEach(kv => {
            const ks = splitkey(kv.key);
            m[ks[0]] = m[ks[0]] || {};
            m[ks[0]][ks[1]] = kv.value;
          });
          // then produce multivalue key/value pairs
          return Object.keys(m).map(k => ({ key: k, value: m[k] }));
        },
      };
    }

    const ndx = crossfilter(experiments),
      runExptDim = ndx.dimension(d => multikey(d.Run, d.Expt)),
      runExptGroup = runExptDim.group().reduceSum(d => d.Speed),
      stackedGroup = stackSecond(runExptGroup);
    const quantizeSpeed = d3
      .scaleQuantize()
      .domain(d3.extent(experiments, d => d.Speed))
      .range(['lowest', 'low', 'medium', 'high', 'highest']);
    const quantizeSpeedDim = ndx.dimension(d => quantizeSpeed(d.Speed)),
      quantizeSpeedGroup = quantizeSpeedDim.group();

    chart
      .dataProvider(
        new dc.CFMultiAdapter({
          dimension: runExptDim,
          layers: [1, 2, 3, 4, 5].map(i => ({
            group: stackedGroup,
            name: `${i}`,
            valueAccessor: d => d.value[i],
          })),
        })
      )
      .configure({
        controlsUseVisibility: true,
        brushOn: false,
        clipPadding: 10,

        title: function (d) {
          return `${d.key}[${this.name}]: ${d.value[this.name]}`;
        },

        renderLabel: true,
      })
      .x(d3.scaleLinear().domain([1, 21]))
      .margins({ left: 40, top: 20, right: 10, bottom: 20 });

    // eslint-disable-next-line no-shadow
    chart.on('pretransition', chart => {
      chart
        .selectAll('rect.bar')
        .classed('stack-deselected', d => {
          // display stack faded if the chart has filters AND
          // the current stack is not one of them
          const key = multikey(d.x, d.name);
          return chart.filter() && chart.filters().indexOf(key) === -1;
        })
        .on('click', (evt, d) => {
          chart.filter(multikey(d.x, d.name));
          chartGroup.redrawAll();
        });
    });

    pie
      .dataProvider(
        new dc.CFSimpleAdapter({
          dimension: quantizeSpeedDim,
          group: quantizeSpeedGroup,
        })
      )
      .configure({
        controlsUseVisibility: true,
        minWidth: 20,
        minHeight: 20,
      });

    chartGroup.renderAll();
  });
</script>
